import React, { createContext, useContext, useState, useEffect, useMemo, useCallback, ReactNode } from 'react';
import { supabase, Database } from '../lib/supabase';
import { useAuth } from './AuthContext';
import { useToast } from './ToastContext';
import { format } from 'date-fns';

type Trade = Database['public']['Tables']['trades']['Row'];
type NewTrade = Database['public']['Tables']['trades']['Insert'];
type UpdateTrade = Database['public']['Tables']['trades']['Update'];

export interface JournalStats {
  totalTrades: number;
  totalWins: number;
  totalLosses: number;
  winrate: number;
  netProfit: number;
  avgProfit: number;
  avgLoss: number;
  payoffRatio: number;
  maxDrawdown: number;
  expectancy: number;
  avgProfitLoss: number;
  winrateByAsset: { [asset: string]: { wins: number; total: number; winrate: number } };
}

interface JournalContextType {
  trades: Trade[];
  stats: JournalStats;
  equityCurve: { day: string; balance: number }[];
  loading: boolean;
  error: string | null;
  addTrade: (tradeData: NewTrade) => Promise<void>;
  updateTrade: (tradeId: string, updates: UpdateTrade) => Promise<void>;
  deleteTrade: (tradeId: string) => Promise<void>;
  fetchTrades: () => Promise<void>;
}

const JournalContext = createContext<JournalContextType | undefined>(undefined);

export const useJournal = () => {
  const context = useContext(JournalContext);
  if (!context) {
    throw new Error('useJournal must be used within a JournalProvider');
  }
  return context;
};

export const JournalProvider: React.FC<{ children: ReactNode }> = ({ children }) => {
  const { user, signOut } = useAuth();
  const toast = useToast();
  const [trades, setTrades] = useState<Trade[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  const fetchTrades = useCallback(async () => {
    if (!user) return;
    setLoading(true);
    setError(null);
    try {
      const { data, error } = await supabase
        .from('trades')
        .select('*')
        .eq('user_id', user.id)
        .order('trade_date', { ascending: true }); // Ascending for equity curve calculation
      if (error) throw error;
      setTrades(data || []);
    } catch (err: any) {
      if (err?.code === 'PGRST303' || err?.message?.includes('JWT expired')) {
        setError('Sua sessão expirou. Você será desconectado.');
        toast.error('Sessão expirada', 'Por favor, faça login novamente.');
        setTimeout(() => signOut(), 3000);
      } else {
        setError('Falha ao carregar operações.');
        console.error(err);
      }
    } finally {
      setLoading(false);
    }
  }, [user, signOut, toast]);

  useEffect(() => {
    fetchTrades();
  }, [fetchTrades]);

  const addTrade = async (tradeData: NewTrade) => {
    if (!user) throw new Error("Usuário não autenticado.");
    try {
      const { data, error } = await supabase
        .from('trades')
        .insert({ ...tradeData, user_id: user.id })
        .select();
      if (error) throw error;
      if (data) {
        setTrades(prev => [...prev, ...data].sort((a, b) => new Date(a.trade_date).getTime() - new Date(b.trade_date).getTime()));
      }
    } catch (err: any) {
      if (err?.code === 'PGRST303' || err?.message?.includes('JWT expired')) {
        toast.error('Sessão expirada', 'Não foi possível salvar. Faça login novamente.');
        setTimeout(() => signOut(), 3000);
      } else {
        throw err;
      }
    }
  };

  const updateTrade = async (tradeId: string, updates: UpdateTrade) => {
    if (!user) throw new Error("Usuário não autenticado.");
    try {
      const { data, error } = await supabase.from('trades').update(updates).eq('id', tradeId).select();
      if (error) throw error;
      if (data) {
        setTrades(prev => prev.map(t => t.id === tradeId ? data[0] : t).sort((a, b) => new Date(a.trade_date).getTime() - new Date(b.trade_date).getTime()));
      }
    } catch (err: any) {
        if (err?.code === 'PGRST303' || err?.message?.includes('JWT expired')) {
            toast.error('Sessão expirada', 'Não foi possível salvar. Faça login novamente.');
            setTimeout(() => signOut(), 3000);
        } else {
            throw err;
        }
    }
  };

  const deleteTrade = async (tradeId: string) => {
    if (!user) throw new Error("Usuário não autenticado.");
    try {
        const { error } = await supabase.from('trades').delete().eq('id', tradeId);
        if (error) throw error;
        setTrades(prev => prev.filter(t => t.id !== tradeId));
    } catch (err: any) {
        if (err?.code === 'PGRST303' || err?.message?.includes('JWT expired')) {
            toast.error('Sessão expirada', 'Não foi possível excluir. Faça login novamente.');
            setTimeout(() => signOut(), 3000);
        } else {
            throw err;
        }
    }
  };

  const { stats, equityCurve } = useMemo(() => {
    const totalTrades = trades.length;
    if (totalTrades === 0) {
      const defaultStats: JournalStats = { totalTrades: 0, totalWins: 0, totalLosses: 0, winrate: 0, netProfit: 0, avgProfit: 0, avgLoss: 0, payoffRatio: 0, maxDrawdown: 0, expectancy: 0, avgProfitLoss: 0, winrateByAsset: {} };
      return { stats: defaultStats, equityCurve: [] };
    }

    const wins = trades.filter(t => t.result_usd > 0);
    const losses = trades.filter(t => t.result_usd < 0);

    const totalWins = wins.length;
    const totalLosses = losses.length;
    const winrate = totalTrades > 0 ? (totalWins / totalTrades) * 100 : 0;
    const netProfit = trades.reduce((acc, t) => acc + t.result_usd, 0);

    const totalProfit = wins.reduce((acc, t) => acc + t.result_usd, 0);
    const totalLoss = losses.reduce((acc, t) => acc + t.result_usd, 0);

    const avgProfit = totalWins > 0 ? totalProfit / totalWins : 0;
    const avgLoss = totalLosses > 0 ? Math.abs(totalLoss / totalLosses) : 0;
    const payoffRatio = avgLoss > 0 ? avgProfit / avgLoss : 0;

    const lossRate = 1 - (winrate / 100);
    const expectancy = (winrate / 100 * avgProfit) - (lossRate * avgLoss);
    const avgProfitLoss = totalTrades > 0 ? netProfit / totalTrades : 0;

    let peak = 0;
    let maxDrawdown = 0;
    let currentBalance = 0;
    const equityCurveData = trades.map(trade => {
      currentBalance += trade.result_usd;
      if (currentBalance > peak) {
        peak = currentBalance;
      }
      const drawdown = peak > 0 ? ((peak - currentBalance) / peak) * 100 : 0;
      if (drawdown > maxDrawdown) {
        maxDrawdown = drawdown;
      }
      return { day: format(new Date(trade.trade_date), 'dd/MM/yy'), balance: currentBalance };
    });

    const winrateByAsset = trades.reduce<JournalStats['winrateByAsset']>((acc, trade) => {
      if (!acc[trade.asset]) {
        acc[trade.asset] = { wins: 0, total: 0, winrate: 0 };
      }
      acc[trade.asset].total++;
      if (trade.result_usd > 0) {
        acc[trade.asset].wins++;
      }
      acc[trade.asset].winrate = (acc[trade.asset].wins / acc[trade.asset].total) * 100;
      return acc;
    }, {});

    const calculatedStats: JournalStats = { totalTrades, totalWins, totalLosses, winrate, netProfit, avgProfit, avgLoss, payoffRatio, maxDrawdown, expectancy, avgProfitLoss, winrateByAsset };

    return { stats: calculatedStats, equityCurve: equityCurveData };
  }, [trades]);

  const value = {
    trades: [...trades].sort((a, b) => new Date(b.trade_date).getTime() - new Date(a.trade_date).getTime()),
    stats,
    equityCurve,
    loading,
    error,
    addTrade,
    updateTrade,
    deleteTrade,
    fetchTrades,
  };

  return (
    <JournalContext.Provider value={value}>
      {children}
    </JournalContext.Provider>
  );
};
